enum Category {
  Consumable
  Legion
  Treasure
}

enum Rarity {
  Common
  Epic
  Legendary
  Rare
  Special
  Uncommon
}

interface Metadata {
  id: ID!
}

type Constellation implements Metadata @entity {
  id: ID!
  
  dark: Int!
  earth: Int!
  fire: Int!
  light: Int!
  water: Int!
  wind: Int!
}

type LegionInfo implements Metadata @entity {
  id: ID!

  # constellation: Constellation!
  crafting: Int!
  questing: Int!
  rarity: String!
  "This is `class`, but we can't use that word"
  role: String!
  type: String!
}

type TreasureTier implements Metadata @entity {
  id: ID!

  tier: Int!
}

type Approval @entity {
  id: ID!

  contract: Bytes!
  operator: Bytes!
  users: [UserApproval!]! @derivedFrom(field: "approval")
}

type Token @entity {
  id: ID!

  category: Category
  contract: Bytes!
  "0 = Genesis, 1 = Auxiliary, 2 = Recruit"
  generation: Int
  image: String!
  metadata: Metadata
  name: String!
  owners: [UserToken!]! @derivedFrom(field: "token")
  rarity: Rarity!
  tokenId: BigInt!
}

type User @entity {
  id: ID!

  approvals: [UserApproval!]! @derivedFrom(field: "user")
  pilgrimaging: [Pilgrimage!] @derivedFrom(field: "user")
  tokens: [UserToken!]! @derivedFrom(field: "user")
}

type Pilgrimage @entity {
  id: ID!

  pilgrimageEndTimestamp: BigInt!
  pilgrimageId: BigInt!
  quantity: BigInt!
  token: Token!
  user: User!
}

type UserApproval @entity {
  id: ID!

  approval: Approval!
  user: User!
}

type UserToken @entity {
  id: ID!

  quantity: BigInt!
  token: Token!
  user: User!
}
